<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - MobileGW Data Sync</title>

    <!-- Bootstrap 5.3.3 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/app.css">
    <link rel="stylesheet" href="/css/dashboard.css">

    <!-- Дополнительные стили для новых функций -->
    <style>
        /* Queue Status Indicator */
        .queue-status {
            position: fixed;
            top: 70px;
            right: 20px;
            background: white;
            padding: 10px 20px;
            border-radius: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 14px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
        }

            .queue-status.has-items {
                background: #fff3cd;
                border: 1px solid #ffc107;
            }

            .queue-status.redis-offline {
                background: #f8d7da;
                border: 1px solid #dc3545;
            }

        .queue-icon {
            font-size: 18px;
            animation: pulse 2s infinite;
        }

        .queue-status.has-items .queue-icon {
            animation: rotate 2s linear infinite;
        }

        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Job Status Badges */
        .status-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            display: inline-block;
            text-transform: uppercase;
        }

            .status-badge.status-idle {
                background: #e9ecef;
                color: #495057;
            }

            .status-badge.status-queued {
                background: #cff4fc;
                color: #055160;
                animation: pulse 1.5s infinite;
            }

            .status-badge.status-starting {
                background: #fff3cd;
                color: #664d03;
            }

            .status-badge.status-running {
                background: #ffc107;
                color: #000;
                animation: pulse 1s infinite;
            }

            .status-badge.status-completed {
                background: #d1e7dd;
                color: #0a3622;
            }

            .status-badge.status-failed {
                background: #f8d7da;
                color: #58151c;
            }

        /* Real-time Job Monitor */
        .job-monitor {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            max-height: 400px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            display: none;
            z-index: 1050;
        }

            .job-monitor.active {
                display: block;
            }

        .job-monitor-header {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px 10px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .job-monitor-body {
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .job-monitor-item {
            padding: 10px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 3px solid #007bff;
        }

            .job-monitor-item.running {
                border-left-color: #ffc107;
                background: #fff3cd;
            }

            .job-monitor-item.completed {
                border-left-color: #28a745;
                background: #d1e7dd;
            }

            .job-monitor-item.failed {
                border-left-color: #dc3545;
                background: #f8d7da;
            }

        /* Progress Bar for Running Jobs */
        .job-progress {
            margin-top: 10px;
        }

        .job-progress-bar {
            height: 4px;
            background: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
        }

        .job-progress-bar-fill {
            height: 100%;
            background: #007bff;
            animation: progress 2s ease-in-out infinite;
        }

        @keyframes progress {
            0% {
                width: 0%;
            }

            100% {
                width: 100%;
            }
        }

        /* Notification improvements */
        .toast.job-notification {
            min-width: 300px;
        }

            .toast.job-notification .toast-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
            }

        /* Live Status Indicator */
        .live-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #28a745;
            border-radius: 50%;
            margin-right: 5px;
            animation: blink 2s infinite;
        }

            .live-indicator.offline {
                background: #dc3545;
                animation: none;
            }

        @keyframes blink {
            0%, 100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }
    </style>
</head>
<body>
    <!-- Sidebar (остается как есть) -->
    <nav class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h5 class="mb-0">
                <i class="bi bi-database-fill-gear"></i>
                <span class="sidebar-text">MobileGW Sync</span>
            </h5>
        </div>

        <ul class="sidebar-nav">
            <li class="nav-item">
                <a href="#overview" class="nav-link active" data-page="overview">
                    <i class="bi bi-speedometer2"></i>
                    <span class="sidebar-text">Overview</span>
                </a>
            </li>
            <li class="nav-item">
                <a href="#jobs" class="nav-link" data-page="jobs">
                    <i class="bi bi-calendar-check"></i>
                    <span class="sidebar-text">Jobs</span>
                </a>
            </li>
            <li class="nav-item">
                <a href="#history" class="nav-link" data-page="history">
                    <i class="bi bi-clock-history"></i>
                    <span class="sidebar-text">History</span>
                </a>
            </li>
            <li class="nav-item">
                <a href="#health" class="nav-link" data-page="health">
                    <i class="bi bi-heart-pulse"></i>
                    <span class="sidebar-text">System Health</span>
                </a>
            </li>
            <li class="nav-item">
                <a href="#settings" class="nav-link" data-page="settings">
                    <i class="bi bi-gear"></i>
                    <span class="sidebar-text">Settings</span>
                </a>
            </li>
        </ul>
    </nav>
    <!-- Main Content -->
    <main class="main-content">
        <!-- Top Bar с индикатором соединения -->
        <div class="topbar">
            <button class="btn btn-link" id="sidebarToggle">
                <i class="bi bi-list fs-4"></i>
            </button>

            <div class="topbar-right">
                <!-- Live Connection Status -->
                <span class="connection-status me-3">
                    <span class="live-indicator" id="liveIndicator"></span>
                    <small id="connectionText">Connected</small>
                </span>

                <span class="badge bg-secondary" id="serverTime">--:--:--</span>

                <!-- Job Monitor Toggle -->
                <button class="btn btn-link position-relative" id="jobMonitorToggle" title="Running Jobs">
                    <i class="bi bi-activity fs-5"></i>
                    <span class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-warning d-none" id="runningJobsBadge">
                        0
                    </span>
                </button>

                <button class="btn btn-link position-relative" id="notificationBtn">
                    <i class="bi bi-bell fs-5"></i>
                    <span class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger d-none" id="notificationBadge">
                        0
                    </span>
                </button>

                <button class="btn btn-sm btn-primary" id="refreshBtn">
                    <i class="bi bi-arrow-clockwise"></i> Refresh
                </button>

                <button class="btn btn-sm btn-danger" id="logoutBtn">
                    <i class="bi bi-box-arrow-right"></i> Logout
                </button>
            </div>
        </div>

        <!-- Queue Status Indicator -->
        <div id="queueStatus" class="queue-status">
            <span class="queue-icon">📋</span>
            <span class="queue-text">Queue: Checking...</span>
            <span class="queue-count badge bg-primary d-none">0</span>
        </div>

        <!-- Page Content -->
        <div class="content-area" id="contentArea">
            <!-- Dynamic content will be loaded here -->
        </div>
    </main>

    <!-- Job Monitor Panel -->
    <div class="job-monitor" id="jobMonitor">
        <div class="job-monitor-header">
            <h6 class="mb-0">
                <i class="bi bi-activity"></i> Active Jobs
            </h6>
            <button class="btn btn-sm btn-close" id="jobMonitorClose"></button>
        </div>
        <div class="job-monitor-body" id="jobMonitorBody">
            <!-- Dynamic job status items will be added here -->
        </div>
    </div>

    <!-- Enhanced Notification Toast Container -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3" id="toastContainer"></div>

    <!-- Job Status Modal (for detailed view) -->
    <div class="modal fade" id="jobStatusModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Job Execution Status</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body" id="jobStatusModalBody">
                    <!-- Dynamic content -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="refreshJobStatusBtn">
                        <i class="bi bi-arrow-clockwise"></i> Refresh
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Template for job monitor items -->
    <template id="jobMonitorItemTemplate">
        <div class="job-monitor-item" data-job-id="">
            <div class="d-flex justify-content-between align-items-start">
                <div>
                    <strong class="job-name"></strong>
                    <div class="job-status-text small text-muted"></div>
                </div>
                <span class="status-badge"></span>
            </div>
            <div class="job-progress mt-2 d-none">
                <div class="job-progress-bar">
                    <div class="job-progress-bar-fill"></div>
                </div>
            </div>
            <div class="job-details small mt-2">
                <span class="job-duration"></span>
                <span class="job-records ms-2"></span>
            </div>
        </div>
    </template>
    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/js/core/api.js"></script>
    <script src="/js/core/utils.js"></script>
    <script src="/js/components/charts.js"></script>
    <script src="/js/components/tables.js"></script>
    <script src="/js/components/metrics.js"></script>
    <script src="/js/pages/dashboard.js"></script>

    <!-- Enhanced Dashboard Scripts -->
    <script>
        // Job Status Monitor
        class JobStatusMonitor {
            constructor() {
                this.monitoredJobs = new Map();
                this.monitorPanel = document.getElementById('jobMonitor');
                this.monitorBody = document.getElementById('jobMonitorBody');
                this.runningJobsBadge = document.getElementById('runningJobsBadge');
                this.template = document.getElementById('jobMonitorItemTemplate');
                this.checkInterval = 2000; // Check every 2 seconds
                this.setupEventListeners();
                this.startMonitoring();
            }

            setupEventListeners() {
                document.getElementById('jobMonitorToggle').addEventListener('click', () => {
                    this.toggleMonitorPanel();
                });

                document.getElementById('jobMonitorClose').addEventListener('click', () => {
                    this.hideMonitorPanel();
                });
            }

            toggleMonitorPanel() {
                this.monitorPanel.classList.toggle('active');
            }

            hideMonitorPanel() {
                this.monitorPanel.classList.remove('active');
            }

            async addJob(jobId, jobName) {
                if (!this.monitoredJobs.has(jobId)) {
                    this.monitoredJobs.set(jobId, {
                        id: jobId,
                        name: jobName,
                        status: 'starting',
                        startTime: new Date()
                    });
                    this.updateMonitorUI();
                    this.showMonitorPanel();
                }
            }

            showMonitorPanel() {
                this.monitorPanel.classList.add('active');
            }

            async checkJobStatus(jobId) {
                try {
                    const response = await fetch(`/dashboard/status/${jobId}`, {
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('jwtToken')}`
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        this.updateJobStatus(jobId, data);
                        return data;
                    }
                } catch (error) {
                    console.error(`Error checking status for job ${jobId}:`, error);
                }
                return null;
            }

            updateJobStatus(jobId, statusData) {
                const job = this.monitoredJobs.get(jobId);
                if (job) {
                    job.status = statusData.status;
                    job.lastRun = statusData.lastRun;
                    job.message = statusData.message;

                    // Remove from monitoring if completed or failed
                    if (statusData.status === 'idle' && statusData.lastRun?.EndTime) {
                        setTimeout(() => {
                            this.monitoredJobs.delete(jobId);
                            this.updateMonitorUI();
                        }, 5000); // Keep for 5 seconds after completion
                    }

                    this.updateMonitorUI();
                }
            }

            updateMonitorUI() {
                this.monitorBody.innerHTML = '';

                let runningCount = 0;
                this.monitoredJobs.forEach(job => {
                    const item = this.createMonitorItem(job);
                    this.monitorBody.appendChild(item);
                    if (job.status === 'running' || job.status === 'starting') {
                        runningCount++;
                    }
                });

                // Update badge
                if (runningCount > 0) {
                    this.runningJobsBadge.textContent = runningCount;
                    this.runningJobsBadge.classList.remove('d-none');
                } else {
                    this.runningJobsBadge.classList.add('d-none');
                }

                // Show "No active jobs" message if empty
                if (this.monitoredJobs.size === 0) {
                    this.monitorBody.innerHTML = '<div class="text-center text-muted py-3">No active jobs</div>';
                }
            }

            createMonitorItem(job) {
                const template = this.template.content.cloneNode(true);
                const item = template.querySelector('.job-monitor-item');

                item.dataset.jobId = job.id;
                item.className = `job-monitor-item ${job.status}`;
                item.querySelector('.job-name').textContent = job.name;
                item.querySelector('.job-status-text').textContent = job.message || 'Processing...';

                const statusBadge = item.querySelector('.status-badge');
                statusBadge.textContent = job.status;
                statusBadge.className = `status-badge status-${job.status}`;

                // Show progress bar for running jobs
                if (job.status === 'running') {
                    item.querySelector('.job-progress').classList.remove('d-none');
                }

                // Show duration and records if available
                if (job.lastRun) {
                    const duration = job.lastRun.EndTime
                        ? new Date(job.lastRun.EndTime) - new Date(job.lastRun.StartTime)
                        : new Date() - new Date(job.lastRun.StartTime);

                    item.querySelector('.job-duration').textContent = `⏱️ ${Math.round(duration / 1000)}s`;

                    if (job.lastRun.RecordsProcessed !== undefined) {
                        item.querySelector('.job-records').textContent =
                            `📊 ${job.lastRun.RecordsProcessed} records`;
                    }
                }

                return item;
            }

            async startMonitoring() {
                setInterval(async () => {
                    for (const [jobId, job] of this.monitoredJobs) {
                        if (job.status === 'running' || job.status === 'starting' || job.status === 'queued') {
                            await this.checkJobStatus(jobId);
                        }
                    }
                }, this.checkInterval);
            }
        }

        // Queue Status Monitor
        class QueueMonitor {
            constructor() {
                this.queueElement = document.getElementById('queueStatus');
                this.checkInterval = 5000; // Check every 5 seconds
                this.startMonitoring();
            }

            async checkQueueStatus() {
                try {
                    const response = await fetch('/dashboard/queue-status', {
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('jwtToken')}`
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        this.updateQueueUI(data);
                    }
                } catch (error) {
                    console.error('Error checking queue status:', error);
                    this.updateQueueUI({ isRedisAvailable: false, message: 'Queue offline' });
                }
            }

            updateQueueUI(data) {
                const textElement = this.queueElement.querySelector('.queue-text');
                const countElement = this.queueElement.querySelector('.queue-count');

                if (!data.isRedisAvailable) {
                    this.queueElement.classList.add('redis-offline');
                    this.queueElement.classList.remove('has-items');
                    textElement.textContent = 'Queue: Offline';
                    countElement.classList.add('d-none');
                } else {
                    this.queueElement.classList.remove('redis-offline');

                    if (data.queueLength > 0) {
                        this.queueElement.classList.add('has-items');
                        textElement.textContent = 'Queue: ';
                        countElement.textContent = data.queueLength;
                        countElement.classList.remove('d-none');
                    } else {
                        this.queueElement.classList.remove('has-items');
                        textElement.textContent = 'Queue: Empty';
                        countElement.classList.add('d-none');
                    }
                }
            }

            startMonitoring() {
                this.checkQueueStatus(); // Initial check
                setInterval(() => this.checkQueueStatus(), this.checkInterval);
            }
        }

        // Enhanced trigger job function
        window.enhancedTriggerJob = async function (jobId, jobName) {
            if (!confirm('Запустить эту задачу сейчас?')) return;

            try {
                const response = await fetch(`/dashboard/trigger/${jobId}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('jwtToken')}`
                    }
                });

                const result = await response.json();

                if (result.success) {
                    // Show notification
                    window.dashboardApp.showToast(
                        result.message || 'Задача запущена',
                        result.method === 'redis_queue' ? 'info' : 'success'
                    );

                    // Add to monitor if queued
                    if (result.method === 'redis_queue') {
                        window.jobMonitor.addJob(jobId, jobName || jobId);
                    } else if (result.method === 'direct') {
                        // Show detailed result for direct execution
                        if (result.details) {
                            const details = `
                                Обработано: ${result.details.recordsProcessed} записей
                                Ошибок: ${result.details.recordsFailed || 0}
                                Время: ${result.details.duration.toFixed(2)} сек
                            `;
                            window.dashboardApp.showToast(details, 'success', 5000);
                        }
                    }

                    // Refresh dashboard after a delay
                    setTimeout(() => {
                        if (window.dashboardApp) {
                            window.dashboardApp.loadPage(window.dashboardApp.currentPage);
                        }
                    }, 3000);
                } else {
                    window.dashboardApp.showToast(
                        result.message || 'Ошибка выполнения задачи',
                        'danger'
                    );

                    if (result.errors && result.errors.length > 0) {
                        console.error('Job execution errors:', result.errors);
                    }
                }
            } catch (error) {
                console.error('Error triggering job:', error);
                window.dashboardApp.showToast(`Ошибка: ${error.message}`, 'danger');
            }
        };

        // Initialize monitors when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.jobMonitor = new JobStatusMonitor();
            window.queueMonitor = new QueueMonitor();

            // Update connection status
            const updateConnectionStatus = () => {
                const indicator = document.getElementById('liveIndicator');
                const text = document.getElementById('connectionText');

                if (navigator.onLine) {
                    indicator.classList.remove('offline');
                    text.textContent = 'Connected';
                } else {
                    indicator.classList.add('offline');
                    text.textContent = 'Offline';
                }
            };

            window.addEventListener('online', updateConnectionStatus);
            window.addEventListener('offline', updateConnectionStatus);
            updateConnectionStatus();
        });
    </script>
</body>
</html>